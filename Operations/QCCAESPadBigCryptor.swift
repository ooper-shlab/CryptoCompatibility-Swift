//
//  QCCAESPadBigCryptor.swift
//  CryptoCompatibility
//
//  Translated by OOPer in cooperation with shlab.jp, on 2016/12/6.
//
//
/*
    Copyright (C) 2016 Apple Inc. All Rights Reserved.
    See LICENSE.txt for this sampleâ€™s licensing information

    Abstract:
    Implements AES encryption and decryption with PKCS#7 padding in a way that's suitable for large data sets.
 */

import Foundation

/*! Implements AES encryption and decryption with PKCS#7 padding in a way that's suitable for large data sets.
 *  \details The key difference between this and `QCCAESPadCryptor` is that this operation
 *      reads its input data from a stream and writes its output data to a stream, rather than
 *      requiring the data to be in memory.
 *
 *      In padded AES, the unencrypted data can be of any length wbile the length of the
 *      encrypted data is always an even multiple of the AES block size (`kCCBlockSizeAES128`,
 *      or 16).  Encrypted the data will always increase its length (slightly), while decrypting
 *      it will do the reverse.
 *
 *      This operation supports both EBC and CBC mode.
 *
 *  \warning In most cases you will want to use AES in CBC mode; to do that securely, set the
 *      initialisation vector (via the `ivData` property) to some cryptographically sound
 *      random data.  If you need to use EBC mode, which is generally not recommended, set
 *      the `ivData` property to nil.
 *
 *  \note The designated initialiser for this class is private.  In the unlikely event you
 *      need to subclass it, you will have to make that public.
 *
 *  \note The operation reads and writes the streams synchronously, making it only suitable for
 *      use with file streams.  An operation that supported network streams would be significantly
 *      more complex.
 */

final class QCCAESPadBigCryptor: Operation {
    
    /*! The error domain for the QCCAESPadBigCryptor operation.
     *  \details Codes are Common Crypto error codes, that is, `kCCParamError` and its friends.
     *      Note that this domain is only used for crypto errors.  If there's an error reading
     *      or writing the streams, that error will be returned directly.
     */
    
    static let ErrorDomain = "QCCAESPadBigCryptorErrorDomain"
    
    /*! A stream of data to be encrypted or decrypted.
     *  \details This is set by the init method.
     */
    
    let inputStream: InputStream
    
    /*! A stream in which to place the output data.
     *  \details This is set by the init method.
     *
     *      This still will be opened if necessary (if the stream state is `NSStreamStatusNotOpen`)
     *      and, if it was opened, will be closed at the end.
     */
    
    let outputStream: OutputStream
    
    /*! The key with which to do the encryption or decryption.
     *  \details This is set by the init method.
     *
     *      This still will be opened if necessary (if the stream state is `NSStreamStatusNotOpen`)
     *      and, if it was opened, will be closed at the end.
     *
     *      On error, the content of this stream are unspecified.
     */
    
    let keyData: Data
    
    /*! The initialisation vector for the encryption or decryption.
     *  \details Set this to nil to use EBC mode.  To use CBC mode securely, set this to an
     *      initialisation vector generated by a cryptographically sound random number generator.
     *      Its length must be the AES block size (`kCCBlockSizeAES128`, or 16).
     *
     *      If you set this, you must set it before queuing the operation.
     *
     *  \warning The default value is an initialisation vector all zeroes.  This is not good
     *      from a security standard, although still better than EBC mode.
     */
    
    var ivData: Data?
    
    /*! The error, if any, resulting from encryption or decryption operation.
     *  \details This is set when the operation is finished.  On success, it will be nil.  Or error,
     *      it will hold a value describing that error.  Errors can be in the `QCCAESPadBigCryptorErrorDomain`
     *      but will most likely be in error domains associated with the stream I/O.
     *
     *  \warning Do not expect an error if the data has been corrupted.  The underlying crypto
     *      system does not report errors in that case because it can lead to
     *      padding oracle attacks.  If you need to check whether the data has arrived intact,
     *      use a separate message authentication code (MAC), often generated using HMAC-SHA as
     *      implemented by the QCCHMACSHAAuthentication operation.
     *
     *      <https://en.wikipedia.org/wiki/Padding_oracle_attack>
     */
    
    private(set) var error: Error?
    
    private let op: CCOperation
    private var didOpenInputStream: Bool = false
    private var didOpenOutputStream: Bool = false
    
    private init(op: CCOperation, input inputStream: InputStream, output outputStream: OutputStream, key keyData: Data) {
        self.op = op
        self.inputStream = inputStream
        self.outputStream = outputStream
        self.keyData = keyData
        self.ivData = Data(count: kCCBlockSizeAES128)
        
        super.init()
        
    }
    
    /*! Initialise the object to encrypt data using a key.
     *  \details When initialised this way, the operation will read the input stream, encrypt the data
     *      with the supplied key, and write that to the output stream.
     *
     *      Both the input and output streams are opened if necessary (if the stream state is
     *      `NSStreamStatusNotOpen`) and, if they are opened, will be closed at the end.
     *
     *      On error, the content of the output stream is unspecified.
     *  \param inputStream The source of unencrypted data; this stream can be of any length.
     *  \param outputStream The sink for encrypted data; on success, the final output stream length will
     *      be slightly longer than the input stream length, and that length will always be an even
     *      multiple of the AES block size (`kCCBlockSizeAES128`, or 16).
     *  \param keyData The key used to encrypt the data; its length must must be one of the
     *      standard AES key sizes (128 bits, `kCCKeySizeAES128`, 16 bytes; 192 bits,
     *      `kCCKeySizeAES192`, 24 bytes; 256 bits, `kCCKeySizeAES256`, or 32 bytes).
     *  \returns The initialised object.
     */
    
    convenience init(toEncryptInput inputStream: InputStream, toOutput outputStream: OutputStream, key keyData: Data) {
        self.init(op: CCOperation(kCCEncrypt), input: inputStream, output: outputStream, key: keyData)
    }
    
    /*! Initialise the object to decrypt data using a key.
     *  \details When initialised this way, the operation will read the input stream, decrypt the data
     *      with the supplied key, and write that to the output stream.
     *
     *      Both the input and output streams are opened if necessary (if the stream state is
     *      `NSStreamStatusNotOpen`) and, if they are opened, will be closed at the end.
     *
     *      An error, the content of the output stream is unspecified.
     *  \param inputStream The source of encrypted data; the length of this stream must be an even
     *      multiple of the AES block size (`kCCBlockSizeAES128`, or 16).
     *  \param outputStream The sink for decrypted data; this can of any length although it will only
     *      be slightly shorter than the input stream.
     *  \param keyData The key used to decrypt the data; its length must must be one of the
     *      standard AES key sizes (128 bits, `kCCKeySizeAES128`, 16 bytes; 192 bits,
     *      `kCCKeySizeAES192`, 24 bytes; 256 bits, `kCCKeySizeAES256`, or 32 bytes).
     *  \returns The initialised object.
     */
    
    convenience init(toDecryptInput inputStream: InputStream, toOutput outputStream: OutputStream, key keyData: Data) {
        self.init(op: CCOperation(kCCDecrypt), input: inputStream, output: outputStream, key: keyData)
    }
    
    private func readToInputBuffer(_ inputBuffer: inout Data) {
        // Read bytes from the input stream into the input buffer, setting self.error if something
        // goes wrong.
        //
        // Note that -read:maxLength: might not return the full number of bytes we request, either
        // because it's hit the end of file or because it's having a bad day.  That's OK, we can
        // handle a non-full input buffer.
        //
        // Also note that this does fail if we hit the end of the input stream; rather it returns
        // an empty input buffer.
        
        if self.error == nil {
            let bytesRead = inputBuffer.withUnsafeMutableBytes {mutableBytes in
                self.inputStream.read(mutableBytes, maxLength: inputBuffer.count)
            }
            if bytesRead >= 0 {
                inputBuffer.count = bytesRead
            } else {
                self.error = self.inputStream.streamError
                assert(self.error != nil)  // error on input stream
            }
        }
    }
    
    private func writeFromOutputBuffer(_ outputBuffer: Data) {
        // Write bytes from the output buffer to the output stream, setting self.error if something
        // goes wrong.
        //
        // Note that this does nothing if a) self.error is set, implying that we got an error
        // somewhere 'upstream', or b) the output buffer length is zero.
        //
        // IMPORTANT: -write:maxLength: might not write all the bytes we give it, so we have to loop
        // until we've written everything.
        
        var bytesSoFar = 0
        let bytesTotal = outputBuffer.count
        outputBuffer.withUnsafeBytes {(buffer: UnsafePointer<UInt8>) in
            while self.error == nil && bytesSoFar != bytesTotal {
                let bytesWritten = self.outputStream.write(buffer+bytesSoFar, maxLength: bytesTotal - bytesSoFar)
                if bytesWritten < 0 {
                    self.error = self.outputStream.streamError
                } else if bytesWritten == 0 {
                    self.error = NSError(domain: NSPOSIXErrorDomain, code: Int(EPIPE), userInfo: nil)
                } else {
                    bytesSoFar += bytesWritten
                }
            }
        }
    }
    
    private func processChunkWithCryptor(_ cryptor: CCCryptorRef, inputBuffer: inout Data, outputBuffer: inout Data) -> Bool {
        // Read a chunk of data from the input stream into the input buffer, run it through
        // the cryptor into the output buffer, and then write it to the output stream.
        // If something goes wrong, set self.error.  Return YES if we're all done (either
        // because we read the last chunk from the input stream or because we got an error).
        var err: CCCryptorStatus = CCCryptorStatus(kCCSuccess)
        var bytesToWrite: Int = 0
        
        if self.isCancelled {
            self.error = NSError(domain: NSCocoaErrorDomain, code: NSUserCancelledError, userInfo: nil)
        }
        
        // Read the next chunk of data from the input stream.
        //
        // Note that this does nothing if self.error is set.
        
        self.readToInputBuffer(&inputBuffer)
        
        // Crypt it.
        //
        // Note that if we hit the end of the input stream than the input buffer will
        // have a length of zero, meaning we should call CCCryptorUpdate to get any
        // bytes that are left over in the cryptor.
        
        if self.error == nil {
            if inputBuffer.count != 0 {
                err = inputBuffer.withUnsafeBytes{bytes in
                    outputBuffer.withUnsafeMutableBytes{mutableBytes in
                        CCCryptorUpdate(
                            cryptor,
                            bytes, inputBuffer.count,
                            mutableBytes, outputBuffer.count,
                            &bytesToWrite)
                    }
                }
            } else {
                err = outputBuffer.withUnsafeMutableBytes{mutableBytes in
                    CCCryptorFinal(
                        cryptor,
                        mutableBytes, outputBuffer.count,
                        &bytesToWrite)
                }
            }
            if err == CCCryptorStatus(kCCSuccess) {
                outputBuffer.count = bytesToWrite
            } else {
                self.error = NSError(domain: QCCAESPadBigCryptor.ErrorDomain, code: Int(err), userInfo: nil)
            }
        }
        
        // Write it out to the output stream.
        //
        // Note that this does nothing if self.error is set.
        
        self.writeFromOutputBuffer(outputBuffer)
        
        return self.error != nil || inputBuffer.count == 0
    }
    
    private func processStreams(inputBuffer: inout Data, outputBuffer: inout Data) {
        // Processes the input stream and write the results to the input stream, using the input and output
        // buffers as scratch space.  Set self.error if there's a problem.
        
        var cryptor: CCCryptorRef? = nil
        
        // Create the cryptor.
        
        let ivPointer = ivData?.withUnsafeBytes {(ivBytes: UnsafePointer<UInt8>) -> UnsafeMutableRawPointer in
            let ptr = UnsafeMutableRawPointer.allocate(bytes: ivData!.count, alignedTo: 1)
            ptr.initializeMemory(as: UInt8.self, from: ivBytes, count: ivData!.count)
            return ptr
        }
        let err = self.keyData.withUnsafeBytes {keyBytes in
            CCCryptorCreate(
                self.op,
                CCAlgorithm(kCCAlgorithmAES128),
                CCOptions(((self.ivData == nil) ? kCCOptionECBMode : 0) | kCCOptionPKCS7Padding),
                keyBytes, self.keyData.count,
                ivPointer,                                  // will be NULL if ivData is nil
                &cryptor
            )
        }
        if err != CCCryptorStatus(kCCSuccess) {
            self.error = NSError(domain: QCCAESPadBigCryptor.ErrorDomain, code: Int(err), userInfo: nil)
        }
        
        // Process the input, one chunk at a time.
        
        if self.error == nil {
            var done = false
            
            let initialInputBufferLength  = inputBuffer.count
            let initialOutputBufferLength = outputBuffer.count
            
            repeat {
                inputBuffer.count = initialInputBufferLength
                outputBuffer.count = initialOutputBufferLength
                
                done = self.processChunkWithCryptor(cryptor!, inputBuffer: &inputBuffer, outputBuffer: &outputBuffer)
            } while !done
        }
        
        // Clean up.
        
        if cryptor != nil {
            let junk = CCCryptorRelease(cryptor)
            assert(junk == CCCryptorStatus(kCCSuccess))
        }
    }
    
    private func mainAfterParameterChecks() {
        let padLength: Int
        
        // Open the streams if necessary.
        
        if self.inputStream.streamStatus == .notOpen {
            self.inputStream.open()
            self.didOpenInputStream = true
        }
        if self.outputStream.streamStatus == .notOpen {
            self.outputStream.open()
            self.didOpenOutputStream = true
        }
        
        // Allocate the input and output buffers.  We use a 64K buffer, which is generally a good
        // size when reading from a file.
        //
        // Padding can expand the data, so we have to allocate space for that.  The rule for block
        // cyphers, like AES, is that the padding only adds space on encryption (on decryption it
        // can reduce space, obviously, but we don't need to account for that) and it will only add
        // at most one block size worth of space.
        
        if self.op == CCOperation(kCCEncrypt) {
            padLength = kCCBlockSizeAES128
        } else {
            padLength = 0
        }
        var inputBuffer = Data(count: 64 * 1024)
        var outputBuffer = Data(count: inputBuffer.count + padLength)
        
        // Run the cryptor.
        
        self.processStreams(inputBuffer: &inputBuffer, outputBuffer: &outputBuffer)
        
        // Close any streams we opened.
        
        if self.didOpenInputStream {
            self.inputStream.close()
        }
        if self.didOpenOutputStream {
            self.outputStream.close()
        }
    }
    
    override func main() {
        
        // We check for common input problems to make it easier for someone tracing through
        // the code to find problems (rather than just getting a mysterious kCCParamError back
        // from CCCrypt).
        
        var err = kCCSuccess
        let keyDataLength = self.keyData.count
        if keyDataLength != kCCKeySizeAES128 && keyDataLength != kCCKeySizeAES192 && keyDataLength != kCCKeySizeAES256 {
            err = kCCParamError
        }
        if let ivData = self.ivData, ivData.count != kCCBlockSizeAES128 {
            err = kCCParamError
        }
        if err != kCCSuccess {
            self.error = NSError(domain: QCCAESPadBigCryptor.ErrorDomain, code: err, userInfo: nil)
        } else {
            self.mainAfterParameterChecks()
        }
    }
    
}
